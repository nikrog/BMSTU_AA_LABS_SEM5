\chapter{Исследовательская часть}
В текущем разделе будут представлены примеры работы разработанного программного обеспечения, постановка эксперимента и сравнительный анализ реализованных алгоритмов.

\section{Пример работы программного обеспечения}

На рисунке \ref{img:linear.PNG} представлен результат работы программы при последовательной обработке матриц, а на рисунке \ref{img:conveyor.PNG} --- при конвейерной обработке матриц; линейный размер квадратных матриц --- 100, количество матриц --- 10. На данных рисунках первая колонка таблицы --- номер заявки (матрицы), вторая --- номер этапа (номер ленты конвейера), третья --- время начала обработки заявки, четвертая --- время завершения обработки заявки.
Видно, что при последовательной обработке заявки обрабатываются последовательно, то есть сначала первая заявка проходит все этапы обработки, затем вторая и т.д. Также видно, что при конвейерной обработке заявки могут обрабатываться параллельно (на разных лентах конвейера). На рисунке \ref{img:statistic.PNG} представлена статистика по времени ожидания заявок (минимальное, максимальное, среднее, медианное значения в секундах) в каждой из 3 очередей по отдельности, во всех очередях и по времени обработки в системе при конвейерной обработке матриц.

\img{180mm}{linear.PNG}{Пример работы программы (последовательная обработка)}
\img{180mm}{conveyor.PNG}{Пример работы программы (конвейерная обработка)}
\imgw{\textwidth}{statistic.PNG}{Пример работы программы (статистика по очередям)}
\clearpage

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнись замеры времени:

\begin{itemize}
	\item операционная система: Windows 10~\cite{windows10};
	\item оперативная память: 16 Гб;
	\item процессор: Intel® Core™ i5 10300H 2.5 ГГц;
	\item 4 физических ядра, 4 логических ядра.
\end{itemize}

Во время замеров времени выполнения реализаций алгоритмов ноутбук был включен в сеть питания и нагружен только встроенными приложениями окружения и системой тестирования.

\section{Время выполнения реализаций алгоритмов построения спектра отрезков}
Для замера времени выполнения реализованных алгоритмов использовалась функция \textit{system\_clock::now(...)} из библиотеки $chrono$. Данная функция возвращает время в наносекундах.

Использовать эту функцию необходимо дважды, затем из конечного времени нужно вычесть начальное, чтобы получить результат.

Замеры времени выполнения конвейерного и последовательного алгоритмов обработки матриц проводились для разного количества матриц (от 10 до 50 с шагом 5, размер матриц --- 100 * 100). Время переводилось из наносекунд в секунды посредством деления на $10^9$.

Результаты замеров времени приведены в таблице \ref{tbl:time_mes_difnum} (время в секундах).
\clearpage
\begin{table}[h]
    \begin{center}
        \caption{Результаты замеров времени в секундах (количество матриц от 10 до 50 с шагом 5, размер --- 100 * 100)}
        \label{tbl:time_mes_difnum}
        \begin{tabular}{|c|c|c|}
            \hline
            Количество матриц & Последовательный & Конвейерный\\
            \hline
             10 & 0.1489 & 0.0852\\ \hline 
            15 & 0.2205 & 0.1161 \\ \hline 
            20 & 0.2945 & 0.1526\\ \hline 
            25 & 0.3676 & 0.2007\\ \hline 
            30 & 0.4384 & 0.2288\\ \hline 
            35 & 0.5104 & 0.2724\\ \hline 
            40 & 0.5825 & 0.2990\\ \hline 
            45 & 0.6599 & 0.3355\\ \hline 
            50 & 0.7327 & 0.3948\\ \hline  
		\end{tabular}
\end{center}
\end{table}

На рисунке \ref{img:f1.png} представлено сравнение времени работы последовательного и конвейрного алгоритмов обработки матриц.

\imgw{\textwidth}{f1.png}{Сравнение времени работы последовательного и конвейрного алгоритмов обработки матриц}

На рисунке \ref{img:stats2.PNG} представлена статистика по времени ожидания заявок (минимальное, максимальное, среднее, медианное значения в секундах) в каждой из 3 очередей по отдельности, во всех очередях и по времени обработки в системе при конвейерной обработке матриц.

\imgw{\textwidth}{stats2.PNG}{Статистика времени обработки заявок}

Можно увидеть, что очереди с наибольшим временем нахождения в них заявки --- первая и вторая. Для первой очереди такой
результат объясняетсяя тем, что она заполняется генератором заранее, и последняя заявка находится в ней до того момента, пока все предшествующие ей не будут обработаны первой лентой. Это подтверждает и среднее время, проведенное заявкой в первой очереди, которое приблизительно равно половине от максимального.

Для второй очереди наибольшее максимальное время нахождения в ней заявки связано со сложностью работы соответсвующей ей ленты. Она приводит матрицы к верхнетреугольному виду, выполняя преобразования над строками и переставляя их, на что затрачивается большое количество операций и, соответсвенно, время. 

\section*{Вывод}
В результате эксперимента было получено, что использование конвейрной обработки эффективнее последовательной реализации по времени работы при количестве матриц, равном 10, в 1.75 раз, а при количестве матриц, равном 50, уже в 1.88 раз. Следовательно, преимущество конвейерного алгоритма обработки матриц над последовательным растет с увеличением количества задач, в данном случае матриц.
